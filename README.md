![image](https://github.com/user-attachments/assets/1e396d08-bc4f-4d71-9497-802b804bf649)# 📌 기획
---
## ✅ 장르 : 방치형 디펜스
- **2D 픽셀 그래픽, Top-Down View**
- **유닛과 타워를 이용해서 집을 지켜라!**
- **일일 보상 및 퀘스트를 통해서 가챠와 연구를 해 보세요**


## ✅ 스토리
[이미지 넣을 예정]

전국적으로 **전세 대란**이 벌어진 현대 판타지 세계.

도시와 시골을 가리지 않고 **집값**은 치솟고, 사람들은 저렴한 전세를 찾아 이세계급 고생을 하고 있다.

당신은 사회 초년생으로, 
결국 구락(舊樂)부동산을 통해 
겨우 찾아낸 **시세 절반의 전세집**에 입주한다.
하지만 입주 직후부터 기묘한 점이 눈에 띈다.

밤마다 들리는 **쿵쿵거리는 함성** 소리
아침에 현관문을 열면 **모험가들이 기절해** 있다

그리고 마침내 알게 된다.
이 집, 사실은 오래된 던전의 폐허 위에 지어진,
**아직 안 죽은 던전**이었다.

## ✅ 개발 타임라인
- **개발 기간: 2025.04.04 ~ 2025.06.02**

- **🗓️ 타임라인**

| **주차** | **내용** |
|---------|----------|
| **1주차** | S.A 작성, UI, 데이터 바인딩 |
| **2주차** | 프레임 워크 작성 |
| **3주차** | 유닛, 적군 (소환, 이동, 공격, 사망, 부활), 인벤토리 및 인벤토리UI, 타워 빌드 시스템 구현, 구글시트 작업 |
| **4주차** | 무한 웨이브 시스템 구현, 사운드 매니저 구현, 중간발표용 MVP 제작 |
| **5주차** | 보스 추가 및 SpriteTrail 제작 및 커스텀툴 구현, 파이어베이스 연동 |
| **6주차** | UI/UX 개선, 파이어베이스 클라우드 펑션 작업 |
| **7주차** | 애널리틱스 연동 및 UI 추가 및 개선 (경고창 및 색상 조정) |
| **8주차** | 유저 피드백 기반 버그 수정 (밸런스 패치, UI 개선, 에러방지 코드 추가 작업) |

<br>
<br>
<br>

# 🧩 사용한 기술 스택
---
[이미지 넣을 예정]

- 💠 **프레임워크 & 언어**: C#, .NET 7.0
- 🧰 **개발환경**: Visual Studio 2022, Windows 10/11
- 📊 **데이터 관리**: Google Spreadsheet, Firebase

<br>
<br>
<br>


# 🎮 게임 사이클
---
[이미지 넣을 예정]


<br>
<br>
<br>


# 🖥️ Preview
<details>
 <summary>미리보기</summary>
<br>
<br>

**🔃 로딩씬**
- 게임 시작 전 로딩 화면 입니다.
- 게임에 유용한 팁을 알려주는 메세지가 나옵니다.
- 게임 시작 전 로딩화면 띄워줍니다.
- 이 화면을 보면서 유저가 잠시 동안 게임 데이터가 로드되는 것을 기다려줍니다.
- 가끔 게임에 필요한 유용한(?) 팁을 알려줍니다.

<br>
<br>

**📗 튜토리얼** 

- 튜토리얼 화면 입니다.
- 처음에 게임을 어떻게 플레이 해야 되는지 가르쳐줍니다.

<br>
<br>

**👾 전투씬** 

일반 전투

이미지 넣을 예정

보스 전투

이미지 넣을 예정

- 몬스터와 타워를 이용해 집을 침범한 용사들을 처치합니다.
- 10웨이브 마다 보스 전투를 합니다.
- 일반 전투에서 골드를 받고 보스 전투에서는 잼을 획득합니다.
- 전투와 퀘스트를 해서 얻은 보상으로 몬스터와 타워를 강화 시켜서 집을 지킵니다.

<br>
<br>

**📋 관리** 

- 내가 보유한 몬스터와 타워를 관리하는 인벤토리를 볼 수 있습니다.
- 인벤토리에서 현재 보유한 몬스터와 타워의 수를 확인 할 수 있습니다.
- 또한 현재 각각에 대한 카드 보유 수를 확인 할 수 있으며, 강화를 시킬 수 있습니다.

<br>
<br>

**📖 도감** 



- 도감에서 현재 보유 중인 몬스터와 타워에 대한 정보를 알 수 있습니다.
- 보유하지 않은 몬스터와 타워는 블랙박스로 보여집니다.

<br>
<br>

**🔭 연구** 

- 연구에서 몬스터와 타워의 공격력과 방어력을 올릴 수 있습니다.
- 또한 지켜야 할 코어에 체력도 올릴 수 있습니다.
- 골드와 잼을 사용해 시간을 단축 시킬 수 있습니다.

<br>
<br>


**💠 뽑기** 

- 잼을 소모해서 몬스터와 타워를 뽑을 수 있습니다.

<br>
<br>

**💰 오프라인 보상**

- 게임에서 로그아웃하고 나가면 나간 시간 동안을 계산해서 오프라인 보상을 지급해줍니다.
- 광고 시청 시 2배로 받을 수 있습니다.

<br>
<br>

**📜 퀘스트** 

- 유저가 목표를 가지고 플레이 할 수 있게 퀘스트를 구현했습니다.
- 일일 퀘스트는 하루 동안 완료해야 되는 퀘스트이며, 업적 퀘스트는 게임을 하면서 특정 조건을 달성하면 얻을 수 있는 보상입니다.
- 반복퀘스트를 넣어서 플레이어가 꾸준히 게임을 플레이하게 했습니다.

</details>

<br>
<br>
<br>

# ❓ 기술적인 도전과제
---
<details>
 <summary>UI 자동 바인딩</summary>

 - **도입배경**
    - Unity에서 [SerializedField] 필드에 오브젝트를 수동으로 바인딩하는 과정은 반복적이고 오류가 발생하기 쉬움. 오브젝트 수가 많아질수록 바인딩 누락이나 연결 오류가 늘어나 개발 효율이 저하됨. 이를 자동화하여 생산성과 안정성을 높이기 위해 도입함.
 - **개선 사항**
   - 런타임중 성능을 중점적으로 생각해서 OnValidate()를 사용
   - OnValidate() 활용해서 하이어라키창의 게임오브젝트의 이름과 [SerializedField]로 표시된 멤버변수의 이름을 같게 적어주면 인스펙터창에 자동 바인딩 되는 코드를 작성
   - 런타임전에 처리해주는 작업과 전처리문으로 플레이중이 아닌 상태에만 처리하도록 설정
   - 바인딩 오류나 누락을 줄여 디버깅 시간을 단축하고, **개발 효율성과 유지보수성을 향상**시킴.
</details>


<details>
 <summary>Firebase 사용 - Realtime Database, Functions, Auth</summary>

 - **Realtime Database**
   - **도입 배경:** 서버를 직접 구축하고 운영할 필요 없이 Firebase Functions에 Javascript로 작성된 함수를 배포하여 뽑기 로직을 처리할 수 있음.
   - **개선 사항:** 뽑기 결과의 무결성과 보안성을 확보하고, 클라이언트 치트 조작에 대한 대응력을 높임.
 - **Functions**
   - **도입 배경:** Firestore의 고급 쿼리 기능보다 단순한 데이터 구조와 빠른 구현이 중요했기 때문에 Realtime Database를 도입.
   - **개선 사항:** 유저 데이터 및 서버 타임스탬프를 수신함으로써, 클라이언트의 로컬 시간 조작에 의한 치트 행위를 방지하고, 주요 상태 변경은 서버에서 판단 및 기록하여 보안성과 추적 가능성을 강화함.
 - **Auth**
   - **도입 배경:** 유저 데이터를 안전하게 저장하고 구분하기 위해, 로그인 없이도 고유한 식별값이 필요했음.
   - **개선 사항:** Firebase Auth를 통해 각 유저에게 고유 ID를 부여함으로써, 로그인 없이도 개인별 데이터 저장 및 관리가 가능해짐.
</details>


<details>
 <summary>Unity Google Sheet 라이브러리 사용</summary>

 - **도입 배경:** Google Sheet를 통해 기획자가 데이터를 편리하게 관리하되, Unity 개발 환경에서도 쉽게 적용할 수 있는 연동 방식이 필요.
 - **개선 사항**
   - Google Sheet 데이터를 JSON으로 변환하고, Unity에서 이를 역직렬화하여 활용하는 워크플로우를 구축함으로써, 기획과 개발 간의 협업 효율이 크게 향상.
   - 또한 라이브러리에서 자동으로 생성해주는 C# 테이블 클래스들이 모두 *ITable* 인터페이스를 공통적으로 상속하고 있어 통합 관리 가능해짐. ⇒ 다양한 Google Sheet 데이터를 Dictionary에 묶어 직관적인 관리 가능해짐.
</details>


<details>
 <summary>상태 패턴</summary>

 - **도입 배경:** 게임 내 엔티티와 타워들이 Idle, Chase, Attack, Dead 등 여러 상태를 가지며, 상태 전환 로직이 점점 복잡해지면 if–else나 switch 문이 중첩되기때문에 가독성과 유지보수가 어려워집니다. 따라서 코드구조를 유지보수하기 쉽고, 버그 수정에도 유연하게 대응하기 위해 도입하게 되었습니다.
 - **개선 사항**
   - 각 상태(Idle, Move, Attack 등)가 독립된 클래스에 담겨 스크립트가 훨씬 깔끔해졌습니다. 또한 상태 전환 시점 로깅과 단위 테스트가 쉬워져 버그 원인 파악이 빨라지고, 여러 개발자가 충돌 없이 병렬 작업할 수 있게 되었습니다.
</details>


<details>
 <summary>어드레서블(동적 생성)</summary>

 - **도입 배경**
   - 키로 파일관리와 필요한 에셋만 가져오게 하고싶어서 사용
   - 어드레서블은 비동기적으로 파일을 계속 불러오기에 순서를 보장받지 못합니다. 그래서 리소스매니저 (싱글톤)을/를 만들고 한번 더 묶어줬습니다. ( 작업이 끝난 후 매개변수로 받은 액션을 실행 )
   - 최초 한번 불러온 에셋은 딕셔너리에 저장 ( 두번째 호출할때는 비동기가 아니라 바로 가져오는 역할 )
</details>


<details>
 <summary>UI 옵저버 패턴</summary>

 - **도입 배경**
   - 재화 소모(골드, 잼). 유닛 체력 변화, 퀘스트 진행 상태 변화 등 게임 내에서 실시간으로 변경되는 데이터를 UI도 업데이트를 해줘야 했기 때문에 옵저버 패턴을 적용
 - **개선 사항항**
   - 옵저버 패턴을 사용해  데이터가 변경되면 UI에 실시간으로 반영
   - 새로운 UI 요소를 추가할 때도 기존 코드를 수정할 필요 없이 해당 데이터를  Action 델리게이트에 구독만 하면 되기 때문에 확장성 증가
</details>


<details>
 <summary>UI 옵저버 패턴</summary>

 - **도입 배경**
   - 여러 퀘스트 조건을 유연하게 처리하고, 조건 추가 시 유지보수를 쉽게 하기 위해 전략 패턴을 도입
 - **개선 사항**
   - *IQuestConditionEvaluator* 인터페이스 정의
   - 각 퀘스트 조건마다 별도의 evaluator 클래스 구현
   - 전략 패턴을 통해 퀘스트 조건 로직의 구조를 유연하고 확장성 있게 개선할 수 있었음.
</details>


<details>
 <summary>다양한 자료 구조 활용</summary>
 <ul>
  <details>
   <summary><strong>적군의 다양한 컨디션 관리</strong></summary>

   - **도입 배경**
     - If else문으로 작성했기에 계속 수정이 빈번하게 일어나서 Dictionary를 활용
   - **개선 사항**
     - 컨디션을 적용할 적군은 각각의 바디 클래스에서 Dictionary에 추가 작업만 진행
     - ApplyDamage에서는 if else문이 아닌 확인할 컨디션 타입만 받아와주면 if 한 줄만 적어도 처리 가능
   </details>


   <details>
   <summary><strong>타워에서 감지된 적군 관리</strong></summary>

   - **도입 배경**
     - 충돌트리거로 감지된 적군은 실시간으로 추가/제거되어야 하고, *LateUpdate*에서는 이미 사망한 적군을 지속적으로 제거해야 하기 때문에 삽입, 삭제, 순회가 빈번히 일어남.
     - 기존의 List를 사용 시 중간 요소를 삭제할 때마다 요소들을 앞으로 이동시키는 연산이 발생하는 (죄책감이 드는) 코드를 작성해야 했음. 
   - **개선 사항**
     - *LinkedList*를 활용해 O(1)로 삽입/삭제가 가능해졌고, 순회 중에도 안전하게 제거할 수 있어짐.
   </details>


   <details>
   <summary><strong>타워 배치 좌표 관리</strong></summary>

   - **도입 배경**
     - 타워가 배치된 칸의 그리드 상의 좌표와 타워 ID를 저장해야했음. 
     - 1개의 칸에는 하나의 타워만 존재할 수 있고, 타워 ID는 중복될 수 있으므로, 그리드 좌표를 키로 사용하는 *Dictionary<Vector3Int, int>* 구조를 채택.
   - **개선 사항**
     - 특정 위치에 이미 타워가 배치됐는지 검색하기 편해졌음.
     - 타워 배치 및 철거 로직에서 삽입과 삭제도 부담없이 가능해짐.
   </details>
 </ul>   
</details>


<details>
 <summary>DOTween 애니메이션 적용</summary>

 - **도입 배경**
   - UI 애니메이션을 작업 할 때 유니티 애니메이터의 복잡한 설정 때문에 간결하고 유연한 애니메이션 구현이 어려워 도입하게 되었음.
 - **개선 사항**
   - 여러 애니메이션을 순차적으로 연결하는 시퀀스 구성이 매우 간편해져 복잡한 연출을 쉽게 구현 할 수 있게 되었음.
</details>


<details>
 <summary>에디터 툴 활용</summary>

 - **도입 배경**
   - 테스트에 불편한점이 많아서 간단한 테스트용 ( 개발편의성용 )으로 구현
 - **개선 사항**
   - 빠르게 테스트를 할 수 있어서 작업 속도가 향상 되었음.
</details>


<details>
 <summary>Safe Area</summary>

 - **도입 배경**
   - 다양한 기종의 폰에서 UI 배치가 달라지면서, 카메라 렌즈나 다른 요소에 의해 UI가 가려지는 현상이 발생함.
 - **개선 사항**
   - SafeArea 값을 활용하여 부모 RectTransform의 Min/Max 값을 자동으로 조절함으로써, UI가 가려지는 현상을 성공적으로 방지할 수 있었음.
</details>

<br>
<br>
<br>

# ❓ 최적화
---

<details>
 <summary>오브젝트 풀</summary>

 - **도입배경**
    - 방치형 게임 특성상 오브젝트 수가 많고 교체도 빈번함.
    - - 그런 게임에서 *`Instantiate / Destroy`*를 직접 사용할 경우 GC가 발생하고 프레임드랍을 유발할 수 있음. ⇒ 오브젝트 풀링이 필수적.
 - **자동 풀링 시스템**
   - 이전 프로젝트 경험에서 직접 풀 관리 코드를 작성해야 할 때 작업량이 많아지는 문제를 개선하고자 개발하는 입장에서 풀을 신경쓰지 않아도 되는 방식으로 개발.
   - *Poolable* 컴포넌트를 가진 오브젝트는 우리가 만든 *Instantiate*와 *Destroy* 함수를 사용하기만 하면 자동으로 풀링되도록 제작.
</details>


<details>
 <summary>브레인 / 바디 개별 로딩</summary>

 - **브레인과 바디 구조**
   - Addressable에서 비동기로 받아와서 생성하기 때문에 완전히 로드될 때까지 딜레이가 발생하게 됩니다. 그렇게 되면 그동안 전투를 시작할 수 없기 때문에 나누어 사용했습니다
   - 타워와 적군, 유닛을 만들 때  전투 로직을 담당하는 브레인과 스프라이트와 애니메이터와 같이 시각적으로 보여주는 컴포넌트들을 가진 바디로 나누어서 만드는 것을 구조로 잡았습니다.
</details>


<details>
 <summary>어드레서블(메모리 최적화)</summary>

 - 기존 ResourcesManager방식은 안쓰는 에셋까지 불러오는 작업해야되기에 많이 무겁다 
 - 그래서 사용하는 에셋은 어드레서블에 등록 후 내가 사용하고 싶을때 코드적으로 호출하면 메모리에 등록되는 방식을 사용했다.
</details>


<details>
 <summary>NPOT를 POT로 변환</summary>

 - 모바일 기준으로 출시할 예정이기에 해상도를 낮추고, 리소스 사이즈를 2의 승수로 설정
 - ex) 사용되는 에셋들 중 일부
</details>


<details>
 <summary>전처리문으로 빌드 최적화</summary>

 - *Debug Log* 함수들은 릴리즈 빌드에서도 작동하기에 전처리문을 사용해서 에디터 상에서만 작동되게 사용 
</details>


<details>
 <summary>박싱 / 언박싱 피하기 : 제네릭 활용</summary>

 - 제네릭을 활용하여 데이터를 관리함으로써 불필요한 박싱/언방싱으로 인한 성능 저하와 런타임 오류의 위험을 효과적으로 회피하고, 동시에 타입 안정성과 코드의 재사용성을 극대화할 수 있었습니다. 
 - **Inventory**
 - **Util**
</details>


<br>
<br>
<br>

# ❓ 트러블 슈팅 내용
---

<details>
 <summary>네브메쉬 bake 안되는 현상</summary>

 <ul>
 <h3>문제되는 현상</h2>
  <li>Bake버튼을 눌러도 Bake가 안되는 문제</li>
 <h3>시도 내용</h2>
 <ul>
  <li>컴포넌트가 붙어있는지 확인 ( Navigation Modifier, … Modifier Tilemap 등등)</li>
  <li>Area가 Walkable로 되어있는지 확인</li>
 </ul>

 <h3>해결 방안</h3>
 <ul>
  <li>MapLevel이 프리펩이라서 혹시 인식을 못하는건가 생각을 하며 UnPack후 Bake시도 → 해결</li>
 </ul>

 </ul>
</details>


<details>
 <summary>인벤토리 UI 버튼 초기화 문제</summary>

 <ul>
 <h3>문제되는 현상</h2>
 <li>의도: 버튼 클릭 시 몬스터, 타워 일괄선택 표시가 뜨게 구현했습니다.</li>
 <li>현상</li>
 <ul>
  <li>UI에서 특정 버튼(일괄 선택 버튼) 클릭 시 아무 반응이 없었습니다.</li>
  <li>UI는 정상적으로 표시되지만, 버튼 클릭 이벤트가 비정상적으로 동작했습니다.</li>
 </ul>
 <h3>시도 내용</h2>
 <ul>
  <li>버튼 오브젝트가 정상적으로 할당되어 있는지 확인했습니다.</li>
  <li>AddListener()에서 올바른 메서드가 연결되어 있는지 검토했습니다</li>
  <li>씬에 EventSystem이 존재하는지 확인했습니다. (UI 입력 처리 필수 요소)</li>
  <li>버튼 컴포넌트, 인터랙션 설정, Raycast Target 등의 UI 설정 값 확인했습니다</li>
 </ul>

 <h3>해결 방안</h2>
 <ul>
  <li>AddListener()가 두 번 호출되면서, 버튼 클릭 시 이벤트가 중복 실행되는 문제가 발생했습니다.</li>
  <li>이로 인해 일괄 선택 기능이 예상과 다르게 작동하거나, 무반응처럼 보이는 현상 발생했습니다.</li>
  <li>해결 방법: 버튼 이벤트를 등록하는 초기화 메서드가 여러 번 호출되지 않도록 조정했습니다.</li>
 </ul>
 </ul>
</details>


<details>
 <summary>MyUnit 스텟이 좀비 스텟으로 전부 들어가는 현상</summary>

 <ul>
 <h3>문제되는 현상</h2>
 <li>현상: 타워의 공격력보다 유닛의 공격력이 더 높은데도 타워보다 데미지가 약하게 들어가고 있었습니다. 뭔가 이상하다 싶어서 디버깅을 걸고 찾아보았고 자동부분의 유닛 스텟이 인벤토리에 있는 스텟과 달랐던 것을 확인했습니다. </li>

 
 <h3>시도 내용</h2>
 <ul>
  <li>MyUnit에서 Primary키가 제대로 들어가고있는지, MyUnitStatus에서 Primary키가 들어가는지 디버깅을 하여 문제가 되는부분을 파악하였습니다.</li>
 </ul>

 <h3>해결 방안</h3>
   <ul>
   <li>MyUnitStatus에서 Primary를 저장할수 있도록 생성자를 PrimaryKey를 받는 생성자를 하나 생성하여 Primary키를 저장할 수 있도록 수정했습니다</li>
  </ul>
</ul>
</details>


<details>
 <summary>인벤토리 UI 버튼 초기화 문제</summary>

 <ul>
 <h3>문제되는 현상</h2>
 <li>Firebase에 데이터를 저장 및 로드하는 작업 중에 역직렬화의 대상인 클래스 중 한 곳에서 Null 참조 에러가 발생했습니다.</li>

  
 <h3>시도 내용</h2>
 <ul>
  <li>1. Null이 발생하는 생성자에 중단점을 걸어 어떤 데이터가 Null 인지 파악했습니다. ⇒ 생성자의 파라미터로 들어가는 외부 데이터를 참조하는 부분이 Null이었습니다.</li>
  <li>하지만 해당 외부 데이터가 Null인 채로 호출되면 안 되는 곳이기 때문에 생성자를 의도치 않은 곳에서 호출하고 있다고 의심이 들어 호출 스택을 확인했습니다. ⇒ Json의 CreateObjectUsingCreatorWithParameters 메서드가 호출된 것을 확인하고 역직렬화 과정에서 자동으로 오브젝트를 생성해 주면서 호출됐음을 알 수 있었습니다.</li>
 </ul>

 <h3>해결 방안</h2>
 <ul>
  <li>해당 예외가 발생했던 MyUnitStatus클래스의 생성자의 로직은 역직렬화 시에 필요하지 않기 때문에 매개변수가 없는 생성자를 추가해서 해결했습니다.</li>
 </ul>
 </ul>
</details>


<details>
 <summary>모바일에서 게임 종료 후 저장 실패 이슈</summary>

 <ul>
 <h3>문제되는 현상</h2>
 <li>의도 : 게임 종료 후 파이어베이스 서버에 데이터 저장하게 구현했습니다.</li>
 <li>현상 : 안드로이드 빌드 후 폰에서 게임 실행 후 종료하면 파이어베이스 서버에 데이터가 저장되지 않는 현상 발생했습니다.</li>

  
 <h3>시도 내용</h2>
 <ul>
  <li>유니티 에디터에서 다시 실행 후 종료 후 저장되는지 확인했습니다.</li>
  <li>파이어베이스 서버에 저장하는 부분에 디버깅을 해서 확인했습니다.</li>
  <li>저장하는 데이터가 Json으로 변환되는지 확인했습니다.</li>
 </ul>

 <h3>해결 방안</h2>
 <ul>
  <li>최종 원인은 게임 종료 시점의 Life Cycle 관리에 있음을 파악했습니다.</li>
  <li>게임 종료 시 데이터를 저장하기 위해 Unity의 OnApplicationQuit() 메서드를 사용하고 있었지만, 안드로이드 빌드 환경에서는 OnApplicationQuit()이 항상 호출된다는 보장이 없었습니다.</li>
  <li>해결방법 : 에디터 환경에서는  OnApplicationQuit()에서 저장하고 안드로이드 빌드에서는 백그라운드에서 저장할 수 있도록 OnApplicationPause()에서 저장 로직을 호출 하도록 수정했습니다.</li>
 </ul>
 </ul>
</details>


<details>
 <summary>빌드 이슈</summary>

 <ul>
 <h3>문제되는 현상</h2>
 <li><i>Dependency 'androidx.annotation:annotation-experimental:1.3.0' requires 'compileSdkVersion' to be set to 33 or higher.
Compilation target for module ':launcher' is 'android-32'</i> : compileSdkVersion이 32로 설정되어 있는데, 사용 중인 일부 라이브러리는 최소 34를 요구한다는 에러입니다.</li>
 <li><i>Manifest merger failed :uses-sdk:minSdkVersion 22 cannot be smaller than version 23 declared in library [com.google.firebase:firebase-auth:23.2.0]</i> : minSdkVersion이 22인데, Firebase Auth에서 최소 SDK 23 이상을 요구한다는 에러입니다.</li>
 <li><i>CommandInvokationFailure: Gradle build failed.  ~ Duplicate class kotlinx.coroutines.CompletedExceptionally found in modules jetified-kotlinx-co<message truncated></i> : 특정 라이브러리가 중복 포함되어 있다는 에러입니다.</li>

  
 <h3>시도 내용</h2>
 <li>에러 메시지에 원인이 명확히 명시되어 있기 때문에, 메시지를 분석하며 각각의 원인을 유추했습니다.</li>
 <li>원인</li>
 <ul>
  <li>androidx.credentials 에서 SDK 34 이상을 요구. Firebase Unity SDK 내부적으로 설치되는 부가 라이브러리였습니다.</li>
  <li>Firebase Auth 23.2.0이 요구하는 최소 조건이라고 명시되어 있습니다.</li>
  <li>이전에 Firebase 작업 후 Git에서 추적된 변경 파일들을 뭔지 잘 모른 채 커밋했는데, 그중 일부는 Gradle이 알아서 처리해주는 의존성 파일이었기 때문에 중복 포함되면서 빌드 문제 발생했습니다.</li>
 </ul>

 <h3>해결 방안</h2>
 <ul>
  <li>Unity Project Setting에서 Target API Level을 34로 설정했습니다.</li>
  <li>Unity Project Setting에서 Minimum API Level을 23으로 설정했습니다.</li>
  <li>Unity 프로젝트 폴더에서 중복된 .jar 파일들 직접 제거했습니다.</li>
 </ul>
 </ul>
</details>


<br>
<br>
<br>

# ❓ 사용자 개선 사
---

<details>
 <summary>미완료 퀘스트 버튼 누른 후 닫기 버튼이 안됩니다.</summary>

 <ul>
  <li>퀘스트가 미완료된 경우 버튼을 비활성화했습니다. 또한, 오류가 발생하던 닫기 버튼을 삭제하고 팝업창 뒷배경을 누르면 닫히도록 수정했습니다. </li>
 </ul>
</details>



<details>
 <summary>튜토리얼 중 다른 버튼을 마음껏 누를 수 있습니다.</summary>

 <ul>
  <li>하단 메뉴 중 현재 진행중인 튜토리얼 내용에 해당하는 메뉴만 클릭 가능하도록 수정했습니다.</li>
  <li>게임 플레이와 관련된 UI는 튜토리얼 동안 비활성화 시켰습니다.</li>
 </ul>
</details>


<details>
 <summary>튜토리얼시 손 모양 아이콘이 하이라이트되면 좀 더 쉽게 발견할 듯 하다. & 튜토리얼 대사를 놓친 플레이어는 진행에 어려움을 느낍니다.</summary>

 <ul>
  <li>튜토리얼 커서의 손가락 끝에 빛나는 이미지 추가했습니다.</li>
  <li>튜토리얼 텍스트 일부분에 색상을 넣어 어떤 행위를 해야 하는지 읽히도록 유도하고 대본을 수정했습니다.</li>
 </ul>
</details>


<details>
 <summary>성장/업그레이드 보여주는 수치가 없어서 아쉽습니다.</summary>

 <ul>
  <li>도감에서 유닛 또는 타워 클릭 시, 정보창에서 스탯 오른쪽에 강화 및 연구로 증가된 스탯이 표시되도록 수정했습니다.</li>
 </ul>
</details>


<details>
 <summary>업그레이드 카드 수 게이지바가 있으면 좋겠습니다.</summary>

 <ul>
  <li>강화 탭에서 유닛과 타워 카드 수에 비례하여 게이지가 차오르도록 수정했습니다.</li>
 </ul>
</details>


<details>
 <summary>데미지를 볼 수 없어서 아쉬운데, 전반적으로 아군이 월등하게 센 것 같습니다</summary>

 <ul>
  <li>아군과 적군이 받는 데미지를 표기하는 데미지 인디케이터를 추가했습니다.</li>
 </ul>
</details>


